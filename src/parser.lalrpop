use prelude::*;

use ast;
use data;
use item;
use runtime;
use table;

grammar;

//
//  Items
//

pub Type: item::ObjectType = {
    <Item*> => item::link(<>),
};

Item: (String, item::Item) = {
    TableSignature => (<>.0, item::Item::TableSignature(<>.1)),
    TableTerm => (<>.0, item::Item::TableTerm(<>.1)),
    TableInstance => {
        let instance_name = <>.0;
        let signature = <>.1;
        let implementors = <>.2.into_iter().collect();
        (instance_name, item::Item::TableInstance { signature, implementors })
    },
};

TableTerm: (String, table::TableTerm) = {
    Initializer => (<>.0, table::TableTerm::Constructor(<>.1)),
    Action => (<>.0, table::TableTerm::Action(<>.1)),
};

//
//  Tables
//

TableSignature: (String, Dict<table::SignatureTerm>) = {
    <name: Ident> ":=" "role" "{" <terms: Comma<TableSignatureTerm>> "}" =>
        (name, terms.into_iter().collect()),
};

TableSignatureTerm: (String, table::SignatureTerm) = {
    <Ident> ":" <TermSignature>,
};

TermSignature: table::SignatureTerm = {
    "action" "(" <Comma<DataType>> ")"
        => table::SignatureTerm::Action(<>),
    "initializer" "(" <Comma<DataType>> ")"
        => table::SignatureTerm::Initializer(<>),
};

DataType: data::FieldType = {
    "Num" => data::FieldType::Num,
};

TableInstance: (String, String, Vec<(String, String)>) = {
    <Ident> ":=" <Ident> "{" <Comma<Assignment<Ident>>> "}",
};


//
//  Algorithms
//

Initializer: (String, runtime::Algorithm) = {
    <Ident> ":=" "initializer" <Algorithm>,
};

Action: (String, runtime::Algorithm) = {
    <Ident> ":=" "action" <Algorithm>,
};

Algorithm: runtime::Algorithm = {
    "(" <param_list: Comma<Ident>> ")" "{" <steps: Blocks> "}" => {
        ast::convert_algorithm(ast::Algorithm { <> })
    },
};

Blocks: Vec<ast::Statement> = {
    <blocks: Block*> => blocks.into_iter().flat_map(|x| x).collect()
};

Block: Vec<ast::Statement> = {
    <Statement> => vec![<>],
    "for" <var_name: Ident> "in" <set_name: Ident> "{" <block: Blocks> "}" => {
        let mut block = block;
        let break_offset = block.len() + 1;
        let intro = ast::Statement::SetIterate {
            var_name,
            set_name,
            break_offset,
        };
        block.insert(0, intro);

        block.push(ast::Statement::Continue);

        block
    },
};

Statement: ast::Statement = {
    "BANG;" => ast::Statement::Debug("BANG".into()),
    "print" "(" <Comma<Expression>> ")" ";" => {
        ast::Statement::DebugNums(<>)
    },
    "cancel;" => ast::Statement::CancelWait,
    <results: Comma<Ident>> "=" <expressions: Comma<Expression>> ";" => {
        ast::Statement::Assign{ <> }
    },
    "self" "=" <name: Ident> "{" <terms: Dict<Ident>> "}" ";" => {
        ast::Statement::State { <> }
    },
    "wait" "(" <Expression> ")" ";" => {
        ast::Statement::Wait(<>)
    },
    <set_name: Ident> "." "add" "(" <to_add: Expression> ")" ";" => {
        ast::Statement::SetAdd { <> }
    },
    <set_name: Ident> "." "remove" "(" <to_remove: Expression> ")" ";" => {
        ast::Statement::SetRemove { <> }
    },
    <typ: Ident> "." <table: Ident> "." <init_name: Ident>
        "(" <args: Comma<Expression>> ")" ";"
        => ast::Statement::GotoAlg {
            table: runtime::TablePath::Static(typ, table),
            alg_name: init_name,
            args,
        },
    <object_name: Ident> "." <action_name: Ident>
        "(" <args: Comma<Expression>> ")" ";"
        => ast::Statement::GotoAlg {
            table: runtime::TablePath::Virtual(object_name),
            alg_name: action_name,
            args,
        },
};

//
//  Expressions
//

Expression: ast::Expression = {
    SumExpression,
};

SimpleExpression: ast::Expression = {
    "(" <Expression> ")",
    <Ident> => ast::Expression::MoveVar(<>),
    "copy" "(" <Ident> ")" => ast::Expression::CloneVar(<>),
    <type_name: Ident> "." <table_name: Ident>
        "." <init_name: Ident> "(" <args: Comma<Expression>> ")"
        => ast::Expression::InitObject { <> },
    <object_name: Ident> "."
        <action_name: Ident> "(" <args: Comma<Expression>> ")"
        => ast::Expression::ExecObject { <> },
    "Set" "." "new" "(" ")" => ast::Expression::InitSet,
    "game" "." <function_name: Ident> "(" <args: Comma<Expression>> ")"
        => ast::Expression::ExternCall { <> },
    Number => ast::Expression::Const(<>),
};

SumExpression: ast::Expression = {
    MulExpression,
    <x: SumExpression> "+" <y: MulExpression> =>
        ast::Expression::Add(Box::new(x), Box::new(y)),
    <x: SumExpression> "-" <y: MulExpression> =>
        ast::Expression::Sub(Box::new(x), Box::new(y)),
};
MulExpression: ast::Expression = {
    PowExpression,
    <x: MulExpression> "*" <y: PowExpression> =>
        ast::Expression::Mul(Box::new(x), Box::new(y)),
    <x: MulExpression> "/" <y: PowExpression> =>
        ast::Expression::Div(Box::new(x), Box::new(y)),
};
PowExpression: ast::Expression = {
    <SimpleExpression>,
    <x: PowExpression> "^" <y: SimpleExpression> =>
        ast::Expression::Pow(Box::new(x), Box::new(y)),
};

Number: f64 = {
    r"[0-9]+" => <>.parse().unwrap(),
    r"[0-9]*\.[0-9]+" => <>.parse().unwrap(),
};

//
//  General Purpose Things
//

Dict<T>: Dict<T> = {
    <Comma<Assignment<T>>> => <>.into_iter().collect()
};

Assignment<T>: (String, T) = {
    <Ident> "=" <T>
};

Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.into(),
};

// taken directly from
// http://lalrpop.github.io/lalrpop/tutorial/007_macros.html
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
