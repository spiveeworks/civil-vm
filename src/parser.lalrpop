use prelude::*;

use ast;
use data;
use item;
use runtime;
use table;

grammar;

//
//  Items
//

pub Type: item::ObjectType = {
    <Item*> => item::link(<>),
};

Item: (String, item::Item) = {
    TableSignature => (<>.0, item::Item::TableSignature(<>.1)),
    TableTerm => (<>.0, item::Item::TableTerm(<>.1)),
    TableInstance => {
        let instance_name = <>.0;
        let signature = <>.1;
        let implementors = <>.2.into_iter().collect();
        (instance_name, item::Item::TableInstance { signature, implementors })
    },
};

TableTerm: (String, table::TableTerm) = {
    Constructor => (<>.0, table::TableTerm::Constructor(<>.1)),
    Function => (<>.0, table::TableTerm::Function(<>.1)),
};

//
//  Tables
//

TableSignature: (String, Dict<table::SignatureTerm>) = {
    <name: TypeIdent> ":=" "role" "{" <terms: Comma<TableSignatureTerm>> "}" =>
        (name, terms.into_iter().collect()),
};

TableSignatureTerm: (String, table::SignatureTerm) = {
    <TermIdent> ":" <TermSignature>,
};

TermSignature: table::SignatureTerm = {
    "fun" "(" <Comma<DataType>> ")"
        => table::SignatureTerm::Function(<>),
    "ctor" "(" <Comma<DataType>> ")"
        => table::SignatureTerm::Constructor(<>),
};

DataType: data::FieldType = {
    "Num" => data::FieldType::Num,
};

TableInstance: (String, String, Vec<(String, String)>) = {
    <TypeIdent> ":=" <TypeIdent> "{" <Comma<Assignment<TermIdent>>> "}",
};


//
//  Algorithms
//

Constructor: (String, runtime::Algorithm) = {
    <TermIdent> ":=" "ctor" <Algorithm>,
};

Function: (String, runtime::Algorithm) = {
    <TermIdent> ":=" "fun" <Algorithm>,
};

Algorithm: runtime::Algorithm = {
    "(" <param_list: Comma<TermIdent>> ")" <steps: Block> => {
        ast::convert_algorithm(ast::Algorithm { <> })
    },
};

Statement: ast::Statement = {
    "BANG;" => ast::Statement::Bang,
    <Expression> ";" => {
        let expressions = vec![<>];
        let results = vec![];
        ast::Statement::Evaluate { expressions, results }
    },
    <results: Comma<TermIdent>> "=" <expressions: Comma<Expression>> ";" => {
        ast::Statement::Evaluate { <> }
    },
    "self" "." "data" "=" <Expression> ";" => {
        ast::Statement::State(<>)
    },

    "while" <condition: Expression> <block: Block>
        => ast::Statement::WhileLoop { <> },
    Branches,
    "match" <data: Expression> "{" <arms: Comma<Arm>> <def: DefaultArm?> "}"
        => ast::Statement::Match {
            data,
            arms,
            def: def.unwrap_or(Vec::new()),
        },
};

Block: Vec<ast::Statement> = { "{" <Statement*> "}" };

Branches: ast::Statement = {
    <if_branch: IfBranch> <elifs: ElifBranch*> <else_branch: ElseBranch?> => {
        let mut if_branches = elifs;
        if_branches.insert(0, if_branch);
        let else_branch = else_branch.unwrap_or(Vec::new());
        ast::Statement::Branch {
            if_branches,
            else_branch,
        }
    },
};

ElifBranch: (ast::Expression, Vec<ast::Statement>) = { "else" <IfBranch> };
IfBranch: (ast::Expression, Vec<ast::Statement>) = { "if" <Expression> <Block> };
ElseBranch: Vec<ast::Statement> = { "else" <Block> };

DefaultArm: Vec<ast::Statement> = {
    "_" "=>" <Block>
};
Arm: (String, Vec<String>, Vec<ast::Statement>) = {
    <TypeIdent> "{" <Comma<TermIdent>> "}" "=>" <Block>
};

//
//  Expressions
//

Expression: ast::Expression = {
    SumExpression,
    Comparison,
};

SimpleExpression: ast::Expression = {
    "(" <Expression> ")",
    <TermIdent> => ast::Expression::Var(<>),
    <names: Path<Ident>> "(" <args: Comma<Expression>> ")"
        => ast::Expression::Method { <> },
    Number => ast::Expression::Const(<>),
    "self" => ast::Expression::SelfObject,
    "self" "." "data" => ast::Expression::SelfData,
    <name: TypeIdent> "{" <fields: Comma<Assignment<Expression>>> "}"
        => ast::Expression::Data { <> },
};

Comparison: ast::Expression = {
    <x: SumExpression> <ops: (ComparisonOp SumExpression)+>
        => ast::Expression::Comparison(Box::new(x), ops),
};

ComparisonOp: ast::CompareOp = {
    "==" => ast::CompareOp::Equals,
    "!=" => ast::CompareOp::NEquals,
    "<=" => ast::CompareOp::LessEq,
    ">=" => ast::CompareOp::GreaterEq,
    "<" => ast::CompareOp::Less,
    ">" => ast::CompareOp::Greater,
};

SumExpression: ast::Expression = {
    MulExpression,
    <x: SumExpression> "+" <y: MulExpression> =>
        ast::Expression::Add(Box::new(x), Box::new(y)),
    <x: SumExpression> "-" <y: MulExpression> =>
        ast::Expression::Sub(Box::new(x), Box::new(y)),
};
MulExpression: ast::Expression = {
    PowExpression,
    <x: MulExpression> "*" <y: PowExpression> =>
        ast::Expression::Mul(Box::new(x), Box::new(y)),
    <x: MulExpression> "/" <y: PowExpression> =>
        ast::Expression::Div(Box::new(x), Box::new(y)),
};
PowExpression: ast::Expression = {
    <SimpleExpression>,
    <x: PowExpression> "^" <y: SimpleExpression> =>
        ast::Expression::Pow(Box::new(x), Box::new(y)),
};

Number: f64 = {
    r"[0-9]+" => <>.parse().unwrap(),
    r"[0-9]*\.[0-9]+" => <>.parse().unwrap(),
};

//
//  General Purpose Things
//

Dict<T>: Dict<T> = {
    <Comma<Assignment<T>>> => <>.into_iter().collect()
};

Assignment<T>: (String, T) = {
    <TermIdent> "=" <T>
};

Ident: String = { TermIdent, TypeIdent };

TermIdent: String = {
    r"[a-z_][a-zA-Z0-9_]*" => <>.into(),
};

TypeIdent: String = {
    r"[A-Z][a-zA-Z0-9_]*" => <>.into(),
};

Path<T>: Vec<T> = {
    <v:(<T> ".")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
}

// taken directly from
// http://lalrpop.github.io/lalrpop/tutorial/007_macros.html
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
